From 17575c049b0838a8e8248a7bdf1514c731a63206 Mon Sep 17 00:00:00 2001
From: Nicola Lunghi <nicola.lunghi@emutex.com>
Date: Mon, 18 Dec 2017 16:23:40 +0000
Subject: [PATCH 2/4] AAEONC: added support for IT8528 i2c driver
AAEONEC: checkpatch cleanup of drivers/i2c/busses/i2c-ec.c

Signed-off-by: Nicola Lunghi <nicola.lunghi@emutex.com>
---
 drivers/i2c/busses/Kconfig  |   5 +
 drivers/i2c/busses/Makefile |   1 +
 drivers/i2c/busses/i2c-ec.c | 777 ++++++++++++++++++++++++++++++++++++++++++++
 3 files changed, 783 insertions(+)
 create mode 100644 drivers/i2c/busses/i2c-ec.c

diff --git a/drivers/i2c/busses/Kconfig b/drivers/i2c/busses/Kconfig
index f2dea4e8edb2..06a7a059bb92 100644
--- a/drivers/i2c/busses/Kconfig
+++ b/drivers/i2c/busses/Kconfig
@@ -511,6 +511,11 @@ config I2C_DIGICOLOR
 	  This driver can also be built as a module.  If so, the module
 	  will be called i2c-digicolor.
 
+config I2C_EC
+	tristate "I2C controller found in IT8528 super i/o ic"
+	help
+	  This driver supports the i2c block found in IT8528 super i/o ic.
+
 config I2C_EFM32
 	tristate "EFM32 I2C controller"
 	depends on ARCH_EFM32 || COMPILE_TEST
diff --git a/drivers/i2c/busses/Makefile b/drivers/i2c/busses/Makefile
index 1c1bac87a9db..f431d60d5ba8 100644
--- a/drivers/i2c/busses/Makefile
+++ b/drivers/i2c/busses/Makefile
@@ -46,6 +46,7 @@ i2c-designware-platform-$(CONFIG_I2C_DESIGNWARE_BAYTRAIL) += i2c-designware-bayt
 obj-$(CONFIG_I2C_DESIGNWARE_PCI)	+= i2c-designware-pci.o
 i2c-designware-pci-objs := i2c-designware-pcidrv.o
 obj-$(CONFIG_I2C_DIGICOLOR)	+= i2c-digicolor.o
+obj-$(CONFIG_I2C_EC)		+= i2c-ec.o
 obj-$(CONFIG_I2C_EFM32)		+= i2c-efm32.o
 obj-$(CONFIG_I2C_EG20T)		+= i2c-eg20t.o
 obj-$(CONFIG_I2C_EMEV2)		+= i2c-emev2.o
diff --git a/drivers/i2c/busses/i2c-ec.c b/drivers/i2c/busses/i2c-ec.c
new file mode 100644
index 000000000000..efc8784901ca
--- /dev/null
+++ b/drivers/i2c/busses/i2c-ec.c
@@ -0,0 +1,777 @@
+/****************************************************************************
+ * I2C driver for Aaeon Super-I/O EC                                        *
+ *                                                                          *
+ * Copyright (C) 2016 Jason Wang <jason2wang@aaeon.com.tw>                  *
+ *                                                                          *
+ * This program is free software; you can redistribute it and/or modify     *
+ * it under the terms of the GNU General Public License as published by     *
+ * the Free Software Foundation; either version 2 of the License, or        *
+ * (at your option) any later version.                                      *
+ *                                                                          *
+ * This program is distributed in the hope that it will be useful,          *
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of           *
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the             *
+ * GNU General Public License for more details.                             *
+ *                                                                          *
+ * You should have received a copy of the GNU General Public License        *
+ * along with this program; if not, write to the                            *
+ * Free Software Foundation, Inc.,                                          *
+ * 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.                 *
+ ***************************************************************************/
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/platform_device.h>
+#include <linux/io.h>
+#include <linux/delay.h>
+#include <linux/gpio.h>
+#include <linux/time.h>
+#include <linux/i2c.h>
+
+#define DRVNAME "i2c-ec"
+
+/*
+ * EC-I/O registers
+ */
+
+/* Standard */
+#define EcPortIndex		0x284
+#define EcPortData		0x285
+#define	EcReg_Dev		0x10
+#define EcReg_LDA		0x10
+#define EcReg_Type		0x11
+#define EcReg_FND		0x11
+#define	EcReg_Conf		0x12
+#define EcReg_Dat0		0x13
+#define EcReg_Dat1		0x14
+#define EcReg_SMBUS_Buf1	0x14
+#define EcReg_SMBUS_Buf2	0x14
+#define EcReg_Dat2		0x15
+#define EcReg_Dat3		0x16
+#define EcReg_Dat4		0x17
+#define EcReg_Dat5		0x18
+#define EcReg_Dat6		0x19
+#define EcReg_Dat7		0x1A
+#define EcReg_Dat8		0x1B
+#define EcReg_Dat9		0x1C
+#define EcReg_DatA		0x1D
+#define EcReg_DatB		0x1E
+#define EcReg_DatC		0x1F
+
+#define CMD_Read		0x10
+#define CMD_Write		0x30
+
+#define Flag_Fail		0x02
+#define Flag_Done		0x01
+
+#define Ec_DEVID		0x20	/* Device ID (only check first byte) */
+#define Ec_DEVREV		0x22	/* Device revision */
+#define CHIP_ID_IT8518		0x85
+
+/* SMBUS/SMBUS Host Controller functiuon defines */
+#define API_SMBUS_Dev		0xA7
+#define API_SMBUS_Type		0x01
+#define API_SMBUS_Buf1		0x05
+#define API_SMBUS_Buf2		0x06
+#define SMBUS_Reg_Ctrl		EcReg_Dat1
+#define SMBUS_Reg_Addr		EcReg_Dat2
+#define SMBUS_Reg_Cmd		EcReg_Dat3
+#define SMBUS_Reg_Dat0		EcReg_Dat4
+#define SMBUS_Reg_Dat1		EcReg_Dat5
+#define SMBUS_Reg_DatL		EcReg_Dat4
+#define SMBUS_Reg_DatH		EcReg_Dat5
+#define SMBUS_Reg_ByteCount	EcReg_Dat4
+#define SMBUS_Reg_BlockBuff	EcReg_Dat5
+
+#define API_SMBUS_SendByte	0x04
+#define API_SMBUS_Receive	0x04
+#define API_SMBUS_ReadByte	0x08
+#define API_SMBUS_WriteByte	0x08
+#define API_SMBUS_ReadWord	0x0C
+#define API_SMBUS_WriteWord	0x0C
+
+#define API_SMBUS_BlockRead	0x14
+#define API_SMBUS_BlockWrite	0x14
+
+#define API_I2C_PageRead	0x1C
+#define API_I2C_PageWrite	0x1C
+
+#define API_SMBUS_Read		0x01
+#define API_SMBUS_Write		0x00
+
+#define ec_smbus_write()	ec_write_cmd(API_SMBUS_Dev, API_SMBUS_Type)
+#define ec_smbus_read()		ec_read_cmd(API_SMBUS_Dev, API_SMBUS_Type)
+#define ec_smbus_wbuf1()	ec_write_cmd(API_SMBUS_Dev, API_SMBUS_Buf1)
+#define ec_smbus_wbuf2()	ec_write_cmd(API_SMBUS_Dev, API_SMBUS_Buf2)
+#define ec_smbus_rbuf1()	ec_read_cmd(API_SMBUS_Dev, API_SMBUS_Buf1)
+#define ec_smbus_rbuf2()	ec_read_cmd(API_SMBUS_Dev, API_SMBUS_Buf2)
+
+#define I2C_MAX_RETRIES 1
+
+enum chips { aaeonec };
+
+static const char * const aaeonec_names[] = {
+	"aaeonec"
+};
+
+struct aaeonec_sio {
+	int addr;
+	enum chips type;
+};
+
+struct ec_i2c_bank {
+	struct i2c_adapter adapter;
+	u8 fnd_reg;
+	struct ec_i2c_data *data;
+};
+
+struct ec_i2c_data {
+	struct aaeonec_sio *sio;
+	int nr_bank;
+	struct ec_i2c_bank *bank;
+};
+
+
+
+#define aaeonec_I2C_BANK(_name, _fnd_reg)	\
+	{					\
+		.adapter = {			\
+			.owner			= THIS_MODULE,\
+			.name			= _name, \
+			.retries		= I2C_MAX_RETRIES,	\
+		},				\
+		.fnd_reg = _fnd_reg,	\
+	}
+
+static struct ec_i2c_bank ec_bank[] = {
+	aaeonec_I2C_BANK("EC I2C Host Controller 1", 0x01),
+};
+
+static s32 ec_i2c_access(struct i2c_adapter *adap, u16 addr,
+		       unsigned short flags, char read_write, u8 command,
+		       int size, union i2c_smbus_data *data);
+
+
+static u32 ec_i2c_func(struct i2c_adapter *adapter);
+
+static const struct i2c_algorithm ec_i2c_algorithm = {
+	.smbus_xfer	= ec_i2c_access,
+	.functionality	= ec_i2c_func,
+};
+
+/*
+ * EC-I/O functions.
+ */
+static inline int ec_enter(int addr)
+{
+	/* Don't step on other drivers' I/O space by accident. */
+	if (!request_muxed_region(addr, 2, DRVNAME)) {
+		pr_err(DRVNAME "I/O address 0x%04x already in use\n", addr);
+		return -EBUSY;
+	}
+
+	return 0;
+}
+
+static inline void ec_exit(int addr)
+{
+	release_region(addr, 2);
+}
+
+static inline int superio_inb(int base, int reg)
+{
+	outb(reg, base);
+	return inb(base + 1);
+}
+
+static inline int ec_inb(int offset)
+{
+	outb(offset, EcPortIndex);
+	return inb(EcPortData);
+}
+
+static inline void ec_outb(int offset, int data)
+{
+	outb(offset, EcPortIndex);
+	outb(data, EcPortData);
+}
+
+static inline int check_ec_ready(void)
+{
+	int timeout;
+	int err = 0;
+	int value = 0;
+
+	for (timeout = 0; timeout < 50; timeout++) {
+		msleep(1);
+		value = ec_inb(EcReg_Conf);
+		if ((value & Flag_Fail) == 0x02) {
+			err = -1;
+			pr_err("Flag_Failn %#x\n", (value&Flag_Fail));
+			break;
+		}
+		if ((value & Flag_Done) == 0x01) {
+			err = 0;
+			break;
+		}
+	}
+
+	return err;
+}
+
+static inline int ec_read_cmd(int LDN, int FND)
+{
+	int err = 0;
+
+	ec_outb(EcReg_LDA, LDN);	// Setting Logic Device
+	ec_outb(EcReg_FND, FND);	// Setting Func & Device
+	ec_outb(EcReg_Conf, CMD_Read);	// Enabled Read Command
+	err = check_ec_ready();
+
+	return err;
+}
+
+static inline int ec_write_cmd(int LDN, int FND)
+{
+	int err = 0;
+
+	ec_outb(EcReg_LDA, LDN);		// Setting Logic Device
+	ec_outb(EcReg_FND, FND);		// Setting Func and Device
+	ec_outb(EcReg_Conf, CMD_Write);		// Enabled Write Command
+	err = check_ec_ready();
+
+	return err;
+}
+
+static int ec_smbus_received(int SMBUS_SlvAddr)
+{
+	int err = 0;
+
+	ec_outb(SMBUS_Reg_Addr, (((SMBUS_SlvAddr & 0x7f) << 1) | 0x01));
+	ec_outb(SMBUS_Reg_Ctrl, API_SMBUS_Receive);
+	err = ec_smbus_write();
+	err = ec_smbus_read();
+	if (err)
+		return err;
+
+	// pr_info("received data 0x%04x\n", ec_inb(SMBUS_Reg_DatL));
+	return ec_inb(SMBUS_Reg_DatL);
+}
+
+static int ec_smbus_rbyte(int SMBUS_SlvAddr, int SMBUS_CmdCode)
+{
+	int err = 0;
+
+	ec_outb(SMBUS_Reg_Addr, (((SMBUS_SlvAddr & 0x7f) << 1) | 0x01));
+	ec_outb(SMBUS_Reg_Cmd, SMBUS_CmdCode);
+	ec_outb(SMBUS_Reg_Ctrl, API_SMBUS_ReadByte);
+	err = ec_smbus_write();
+	if (err < 0)
+		return err;
+
+	err = ec_smbus_read();
+	if (err < 0)
+		return err;
+
+	//pr_info("ec_smbus_rbyte : %#x\n", ec_inb(SMBUS_Reg_DatL));
+	return ec_inb(SMBUS_Reg_DatL);
+}
+
+static int ec_smbus_rword(int SMBUS_SlvAddr, int SMBUS_CmdCode)
+{
+	int err = 0;
+
+	ec_outb(SMBUS_Reg_Addr, (((SMBUS_SlvAddr & 0x7f) << 1) | 0x01));
+	ec_outb(SMBUS_Reg_Cmd, SMBUS_CmdCode);
+	ec_outb(SMBUS_Reg_Ctrl, API_SMBUS_ReadWord);
+	err = ec_smbus_write();
+	if (err)
+		return err;
+
+	err = ec_smbus_read();
+	if (err)
+		return err;
+
+	return ec_inb((SMBUS_Reg_DatH)<<8|ec_inb(SMBUS_Reg_DatL));
+}
+
+static int ec_smbus_rblock(u8 SMBUS_SlvAddr, u8 SMBUS_CmdCode, u8 *buffer)
+{
+	int i;
+	int err = 0;
+	u8 bytecount = 0;
+
+	ec_outb(SMBUS_Reg_Addr, (((SMBUS_SlvAddr & 0x7f) << 1) | 0x01));
+	ec_outb(SMBUS_Reg_Cmd, SMBUS_CmdCode);
+	ec_outb(SMBUS_Reg_Ctrl, API_SMBUS_BlockRead);
+	err = ec_smbus_write();
+	if (err < 0)
+		return err;
+
+	err = ec_smbus_read();
+	if (err < 0)
+		return err;
+
+	bytecount = ec_inb(SMBUS_Reg_ByteCount);
+	if (bytecount < 0)
+		return bytecount;
+
+	pr_info("ec_smbus_rblock : bytecount %d\n", bytecount);
+
+	for (i = 1; i < 9; i++) {
+		*(buffer+i) = ec_inb(SMBUS_Reg_ByteCount + i);
+		pr_info("ec_smbus_rblock : buffer%d %#x\n", i, *(buffer+i));
+	}
+
+	if (bytecount > 8) {
+		ec_smbus_rbuf1();
+		if (err)
+			return err;
+
+		for (i = 0; i < 12; i++)
+			*(buffer + 9 + i) = ec_inb(EcReg_SMBUS_Buf1 + i);
+	}
+
+	if (bytecount > 20) {
+		ec_smbus_rbuf2();
+		if (err)
+			return err;
+
+		for (i = 0; i < 12; i++)
+			*(buffer+21+i) = ec_inb(EcReg_SMBUS_Buf2+i);
+	}
+
+	return bytecount;
+}
+
+int ec_smbus_send(int SMBUS_SlvAddr, int SMBUS_CmdCode)
+{
+	int err = 0;
+
+	ec_outb(SMBUS_Reg_Addr, ((SMBUS_SlvAddr & 0x7f) << 1));
+	ec_outb(SMBUS_Reg_Cmd, SMBUS_CmdCode);
+	ec_outb(SMBUS_Reg_Ctrl, API_SMBUS_SendByte);
+	err = ec_smbus_write();
+
+	return err;
+}
+
+int ec_smbus_wbyte(int SMBUS_SlvAddr, int SMBUS_CmdCode, int SMBUS_ByteData)
+{
+	int err = 0;
+
+	ec_outb(SMBUS_Reg_Addr, ((SMBUS_SlvAddr & 0x7f) << 1));
+	ec_outb(SMBUS_Reg_Cmd, SMBUS_CmdCode);
+	ec_outb(SMBUS_Reg_Ctrl, API_SMBUS_WriteByte);
+	ec_outb(SMBUS_Reg_DatL, SMBUS_ByteData);
+	err = ec_smbus_write();
+
+	return err;
+}
+
+int ec_smbus_wword(int SMBUS_SlvAddr, int SMBUS_CmdCode, int SMBUS_WordData)
+{
+	int err = 0;
+
+	ec_outb(SMBUS_Reg_Addr, ((SMBUS_SlvAddr & 0x7f) << 1));
+	ec_outb(SMBUS_Reg_Cmd, SMBUS_CmdCode);
+	ec_outb(SMBUS_Reg_Ctrl, API_SMBUS_WriteWord);
+	ec_outb(SMBUS_Reg_DatL, (SMBUS_WordData & 0xff));
+	ec_outb(SMBUS_Reg_DatH, ((SMBUS_WordData >> 8) & 0xff));
+	err = ec_smbus_write();
+
+	return err;
+}
+
+int ec_smbus_wblock(u8 SMBUS_SlvAddr, u8 SMBUS_CmdCode, u8 *buffer)
+{
+	int i;
+	int err = 0;
+	u8 bytecount;
+
+	bytecount = *(buffer);
+
+	if (bytecount > 20) {
+		for (i = 0; i < 12; i++)
+			ec_outb((EcReg_SMBUS_Buf2 + i), *(buffer + 21 + i));
+
+		err = ec_smbus_wbuf2();
+		if (err)
+			return err;
+	}
+
+	if (bytecount > 8) {
+		for (i = 0; i < 12; i++)
+			ec_outb((EcReg_SMBUS_Buf1+i), *(buffer + 9 + i));
+
+		err = ec_smbus_wbuf1();
+		if (err)
+			return err;
+	}
+
+	for (i = 0; i < 9; i++)
+		ec_outb((SMBUS_Reg_ByteCount + i), *(buffer + i));
+
+	ec_outb(SMBUS_Reg_Addr, ((SMBUS_SlvAddr & 0x7f) << 1));
+	ec_outb(SMBUS_Reg_Cmd, SMBUS_CmdCode);
+	ec_outb(SMBUS_Reg_Ctrl, API_SMBUS_BlockWrite);
+	err = ec_smbus_write();
+	if (err)
+		return err;
+
+	return ec_smbus_read();
+}
+
+int ec_I2C_sequential(u8 SMBUS_SlvAddr, u8 *buffer)
+{
+	int i;
+	int err = 0;
+	u8 bytecount = 0;
+
+	ec_outb(SMBUS_Reg_Addr, (((SMBUS_SlvAddr & 0x7f) << 1) | 0x01));
+	ec_outb(SMBUS_Reg_Ctrl, API_I2C_PageRead);
+	ec_smbus_write();
+	if (err)
+		return err;
+
+	ec_smbus_read();
+	if (err)
+		return err;
+
+	bytecount = ec_inb(SMBUS_Reg_ByteCount);
+	//pr_info("ec_I2C_sequential : bytecount %d\n", bytecount);
+
+	for (i = 1; i < 9; i++)
+		*(buffer + i) = ec_inb(SMBUS_Reg_ByteCount + i);
+
+	if (bytecount > 8) {
+		err = ec_smbus_rbuf1();
+		if (err)
+			return err;
+
+		for (i = 0; i < 12; i++)
+			*(buffer + 9 + i) = ec_inb(EcReg_SMBUS_Buf1 + i);
+	}
+
+	if (bytecount > 20) {
+		err = ec_smbus_rbuf2();
+		if (err)
+			return err;
+		for (i = 0; i < 12 ; i++)
+			*(buffer + 21 + i) = ec_inb(EcReg_SMBUS_Buf2 + i);
+	}
+
+	return bytecount;
+}
+
+int ec_I2C_pagewrite(u8 SMBUS_SlvAddr, u8 *buffer)
+{
+	int i;
+	int err = 0;
+	u8 bytecount = 0;
+
+	bytecount = *(buffer);
+
+	if (bytecount > 20) {
+		for (i = 0; i < 12; i++)
+			ec_outb((EcReg_SMBUS_Buf2+i), *(buffer + 21 + i));
+
+		err = ec_smbus_wbuf2();
+		if (err)
+			return err;
+	}
+
+	if (bytecount > 8) {
+		for (i = 0; i < 12; i++)
+			ec_outb((EcReg_SMBUS_Buf1+i), *(buffer + 9 + i));
+
+		err = ec_smbus_wbuf1();
+		if (err)
+			return err;
+	}
+
+	for (i = 0; i < 9; i++)
+		ec_outb((SMBUS_Reg_ByteCount+i), *(buffer + i));
+
+	ec_outb(SMBUS_Reg_Addr, ((SMBUS_SlvAddr & 0x7f) << 1));
+	ec_outb(SMBUS_Reg_Ctrl, API_I2C_PageWrite);
+	err = ec_smbus_write();
+	err = ec_smbus_read();
+
+	return err;
+}
+
+
+/*
+ * I2C transaction handle
+ * Return negative errno on error.
+ */
+static s32 ec_i2c_access(struct i2c_adapter *adap, u16 addr,
+		       unsigned short flags, char read_write, u8 command,
+		       int size, union i2c_smbus_data *data)
+{
+	int ret = -1;
+	u8 *buf = data->block;
+
+	switch (size) {
+	case I2C_SMBUS_QUICK:
+		if (read_write == I2C_SMBUS_WRITE)
+			ret = ec_smbus_send(addr, command);
+		else
+			ret = ec_smbus_received(addr);
+
+		if (ret)
+			data->byte = ret;
+		else
+			return ret;
+		break;
+
+	case I2C_SMBUS_BYTE:
+		if (read_write == I2C_SMBUS_WRITE)
+			ret = ec_smbus_wbyte(addr,
+					command, (data->byte & 0xff));
+		else
+			ret = ec_smbus_rbyte(addr, command);
+
+		if (ret < 0)
+			return ret;
+
+		data->byte = ret;
+		break;
+
+	case I2C_SMBUS_BYTE_DATA:
+		if (read_write == I2C_SMBUS_WRITE)
+			ret = ec_smbus_wbyte(addr, 0xff, (data->byte & 0xff));
+		else
+			ret = ec_smbus_rbyte(addr, command);
+
+		if (ret < 0)
+			return ret;
+
+		data->byte = ret;
+		break;
+
+	case I2C_SMBUS_WORD_DATA:
+		if (read_write == I2C_SMBUS_WRITE)
+			ret = ec_smbus_wword(addr,
+					command, (data->word & 0xff));
+		else
+			ret = ec_smbus_rword(addr, command);
+
+		if (!ret)
+			return ret;
+
+		data->word = ret;
+		break;
+
+	case I2C_SMBUS_BLOCK_DATA:
+		if (read_write == I2C_SMBUS_WRITE)
+			ret = ec_smbus_wblock(addr, command, buf);
+		else {
+			ret = ec_smbus_rblock(addr, command, data->block);
+			pr_info("I2C_SMBUS_BLOCK_DATA: ret %d\n", ret);
+		}
+		if (ret < 0)
+			return ret;
+
+		break;
+
+	case I2C_SMBUS_I2C_BLOCK_DATA:
+		if (read_write == I2C_SMBUS_WRITE)
+			ret = ec_I2C_pagewrite(addr, buf);
+		else {
+			ret = ec_I2C_sequential(addr, data->block);
+			pr_info("I2C_SMBUS_I2C_BLOCK_DATA: ret %d\n", ret);
+		}
+		if (ret < 0)
+			return ret;
+
+		break;
+
+	default:
+		pr_err(DRVNAME "Unsupported transaction %d\n", size);
+		ret = -EOPNOTSUPP;
+	}
+
+	return 0;
+}
+
+
+static u32 ec_i2c_func(struct i2c_adapter *adapter)
+{
+	return I2C_FUNC_SMBUS_QUICK | I2C_FUNC_SMBUS_BYTE |
+	       I2C_FUNC_SMBUS_BYTE_DATA | I2C_FUNC_SMBUS_WORD_DATA |
+	       I2C_FUNC_SMBUS_BLOCK_DATA | I2C_FUNC_SMBUS_I2C_BLOCK;
+}
+
+
+static int ec_i2c_probe(struct platform_device *pdev)
+{
+	int err;
+
+	struct aaeonec_sio *sio = pdev->dev.platform_data;
+	struct ec_i2c_data *data = 0;
+	struct ec_i2c_bank *bank = 0;
+
+	data = devm_kzalloc(&pdev->dev, sizeof(*data), GFP_KERNEL);
+	if (!data)
+		return -ENOMEM;
+
+	switch (sio->type) {
+	case aaeonec:
+		data->nr_bank = ARRAY_SIZE(ec_bank);
+		data->bank = ec_bank;
+		break;
+	default:
+		return -ENODEV;
+	}
+	data->sio = sio;
+
+	bank = &data->bank[0];
+	i2c_set_adapdata(&bank->adapter, data);
+	bank->adapter.owner = THIS_MODULE;
+	bank->adapter.class = I2C_CLASS_HWMON | I2C_CLASS_SPD;
+	bank->adapter.algo = &ec_i2c_algorithm;
+	bank->adapter.dev.parent = &pdev->dev;
+	bank->data = data;
+	err = i2c_add_adapter(&bank->adapter);
+	if (err) {
+		dev_err(&pdev->dev,
+			"Failed to register i2c adapter %d\n", err);
+		goto err_i2c_adapter;
+	}
+
+	platform_set_drvdata(pdev, data);
+
+	return 0;
+
+err_i2c_adapter:
+	i2c_del_adapter(&bank->adapter);
+
+	return err;
+}
+
+static int ec_i2c_remove(struct platform_device *pdev)
+{
+	struct ec_i2c_data *data = platform_get_drvdata(pdev);
+	struct ec_i2c_bank *bank = &data->bank[0];
+
+	i2c_del_adapter(&bank->adapter);
+
+	devm_kfree(&pdev->dev, data);
+
+	return 0;
+}
+
+static int __init aaeonec_find(int addr, struct aaeonec_sio *sio)
+{
+	int err = 0;
+	u8 devid;
+
+	err = ec_enter(addr);
+	if (err)
+		return err;
+
+	devid = superio_inb(addr, Ec_DEVID);
+	pr_info(DRVNAME ": Finded Fintek device addr:0x%04x ID:%#x\n",
+		addr, Ec_DEVID);
+
+	switch (devid) {
+	case CHIP_ID_IT8518:
+		sio->type = aaeonec;
+		break;
+	default:
+		pr_info(DRVNAME ": Unsupported Fintek device 0x%04x\n", devid);
+		goto exit;
+	}
+	sio->addr = EcPortIndex;
+
+	pr_info(DRVNAME ": Found %s at %#x, ID:%#x, revision %#x\n",
+		aaeonec_names[sio->type],
+		(unsigned int) addr, devid,
+		superio_inb(addr, Ec_DEVREV));
+
+	ec_exit(addr);
+	return 0;
+
+exit:
+	ec_exit(addr);
+	return -ENODEV;
+}
+
+static struct platform_device *ec_i2c_platform_dev;
+
+static int __init
+aaeonec_i2c_device_add(const struct aaeonec_sio *sio)
+{
+	int err;
+
+	ec_i2c_platform_dev = platform_device_alloc(DRVNAME, -1);
+	if (!ec_i2c_platform_dev)
+		return -ENOMEM;
+
+	err = platform_device_add_data(ec_i2c_platform_dev,
+				       sio, sizeof(*sio));
+	if (err) {
+		pr_err(DRVNAME "Platform data allocation failed\n");
+		goto err;
+	}
+
+	err = platform_device_add(ec_i2c_platform_dev);
+	if (err) {
+		pr_err(DRVNAME "Device addition failed\n");
+		goto err;
+	}
+
+	return 0;
+
+err:
+	platform_device_put(ec_i2c_platform_dev);
+
+	return err;
+}
+
+/*
+ * Try to match a supported Fintek device by reading the (hard-wired)
+ * configuration I/O ports. If available, then register both the platform
+ * device and driver to support the GPIOs.
+ */
+
+static struct platform_driver aaeonec_i2c_driver = {
+	.driver = {
+		.name	= DRVNAME,
+	},
+	.probe		= ec_i2c_probe,
+	.remove		= ec_i2c_remove,
+};
+
+static int __init ec_i2c_init(void)
+{
+	int err = 0;
+	struct aaeonec_sio sio;
+
+	if (aaeonec_find(0x6e, &sio) &&
+	    aaeonec_find(0x7e, &sio))
+		return -ENODEV;
+
+	err = platform_driver_register(&aaeonec_i2c_driver);
+	if (!err) {
+		err = aaeonec_i2c_device_add(&sio);
+		if (err)
+			platform_driver_unregister(&aaeonec_i2c_driver);
+	}
+
+	return err;
+}
+subsys_initcall(ec_i2c_init);
+
+static void __exit ec_i2c_exit(void)
+{
+	platform_device_unregister(ec_i2c_platform_dev);
+	platform_driver_unregister(&aaeonec_i2c_driver);
+}
+module_exit(ec_i2c_exit);
+
+MODULE_AUTHOR("JasonWang");
+MODULE_DESCRIPTION("I2C driver for Super-I/O chips EC");
+MODULE_LICENSE("GPL");
-- 
2.15.1

