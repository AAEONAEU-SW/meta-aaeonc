From e4eae306e41db2ba3720157a408dfdffd5c9e099 Mon Sep 17 00:00:00 2001
From: Nicola Lunghi <nicola.lunghi@emutex.com>
Date: Mon, 18 Dec 2017 16:16:40 +0000
Subject: [PATCH 1/4] AAEONC: added support for IT8528 gpio driver

AAEONEC: checkpatch cleanup of drivers/gpio/gpio-ec.c

Signed-off-by: Nicola Lunghi <nicola.lunghi@emutex.com>
---
 drivers/gpio/Kconfig   |   5 +
 drivers/gpio/Makefile  |   1 +
 drivers/gpio/gpio-ec.c | 565 +++++++++++++++++++++++++++++++++++++++++++++++++
 3 files changed, 571 insertions(+)
 create mode 100644 drivers/gpio/gpio-ec.c

diff --git a/drivers/gpio/Kconfig b/drivers/gpio/Kconfig
index f69b839b1fb8..c76ac5b571a2 100644
--- a/drivers/gpio/Kconfig
+++ b/drivers/gpio/Kconfig
@@ -171,6 +171,11 @@ config GPIO_EM
 	help
 	  Say yes here to support GPIO on Renesas Emma Mobile SoCs.
 
+config GPIO_EC
+	tristate "GPIO driver for Finteck Super I/O IT8528 gpio"
+	help
+	  Say yes here to support GPIO on Finteck Super I/O IT8528 chip.
+
 config GPIO_EP93XX
 	def_bool y
 	depends on ARCH_EP93XX
diff --git a/drivers/gpio/Makefile b/drivers/gpio/Makefile
index 7a5bb01725ef..3a1e070883d5 100644
--- a/drivers/gpio/Makefile
+++ b/drivers/gpio/Makefile
@@ -43,6 +43,7 @@ obj-$(CONFIG_GPIO_DA9055)	+= gpio-da9055.o
 obj-$(CONFIG_GPIO_DAVINCI)	+= gpio-davinci.o
 obj-$(CONFIG_GPIO_DLN2)		+= gpio-dln2.o
 obj-$(CONFIG_GPIO_DWAPB)	+= gpio-dwapb.o
+obj-$(CONFIG_GPIO_EC)		+= gpio-ec.o
 obj-$(CONFIG_GPIO_EM)		+= gpio-em.o
 obj-$(CONFIG_GPIO_EP93XX)	+= gpio-ep93xx.o
 obj-$(CONFIG_GPIO_ETRAXFS)	+= gpio-etraxfs.o
diff --git a/drivers/gpio/gpio-ec.c b/drivers/gpio/gpio-ec.c
new file mode 100644
index 000000000000..9bd04edd86c5
--- /dev/null
+++ b/drivers/gpio/gpio-ec.c
@@ -0,0 +1,565 @@
+/***************************************************************************
+ * GPIO driver for Aaeon Super-I/O EC                                       *
+ *                                                                          *
+ * Copyright (C) 2017 Albert Wu <albertwu@aaeon.com.tw>                     *
+ *                                                                          *
+ * Based on gpio-ec.c by Jason Wang <jason2wang@aaeon.com.tw>               *
+ *                       Nick Chen <nick1chen@aaeon.com.tw>                 *
+ *	                                                                    *
+ * This program is free software; you can redistribute it and/or modify     *
+ * it under the terms of the GNU General Public License as published by     *
+ * the Free Software Foundation; either version 2 of the License, or        *
+ * (at your option) any later version.                                      *
+ *                                                                          *
+ * This program is distributed in the hope that it will be useful,          *
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of           *
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the             *
+ * GNU General Public License for more details.                             *
+ *                                                                          *
+ * You should have received a copy of the GNU General Public License        *
+ * along with this program; if not, write to the                            *
+ * Free Software Foundation, Inc.,                                          *
+ * 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.                 *
+ ***************************************************************************/
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/platform_device.h>
+#include <linux/io.h>
+#include <linux/delay.h>
+#include <linux/gpio.h>
+#include <linux/time.h>
+
+#define DRVNAME "gpio-ec"
+
+/*
+ * Super-I/O registers
+ */
+#define SIO_ADDR		0x284
+
+#define SIO_DEVID		0x20	/* Device ID (only check first byte) */
+#define SIO_DEVREV		0x22	/* Device revision */
+
+#define SIO_EC			0x85
+
+//EC API Registers Map Table:
+#define EC_Device      0x10
+#define EC_TypeOffset  0x11
+#define EC_CtlStatus   0x12
+#define EC_Data0       0x13
+#define EC_Data1       0x14
+#define EC_Data2       0x15
+#define EC_Data3       0x16
+#define EC_Data4       0x17
+#define EC_Data5       0x18
+#define EC_Data6       0x19
+#define EC_Data7       0x1A
+#define EC_Data8       0x1B
+#define EC_Data9       0x1C
+#define EC_DataA       0x1D
+#define EC_DataB       0x1E
+#define EC_DataC       0x1F
+
+//Logic Device and Function Map Table :
+#define EC_Func			0xA1
+#define EC_Info			0x02
+
+#define DIO_Func		0xA2
+#define DIO_Direction		0x00
+#define DIO_Data		0x01
+
+#define HWm_Func		0xA5
+#define Temperature_Access	0x00
+#define Voltage_Access_1	0x01
+#define Voltage_Access_2	0x02
+
+#define FAN_CONTROL		0xA6
+#define Fan_Speed_Access_1	0x00
+#define Fan_Speed_Access_2	0x01
+
+#define SMBUS_Device		0xA7
+#define SMBUS_Access		0x00
+
+#define I2C_Access		0x01
+
+#define WDT_Device		0xA8
+#define WDT_Access		0x00
+
+#define BKLC_CONTROL		0xAA
+
+enum chips { aaeonec };
+
+static const char * const aaeonec_names[] = {
+	"aaeonec"
+};
+
+struct aaeonec_sio {
+	int addr;
+	enum chips type;
+};
+
+struct aaeonec_gpio_bank {
+	struct gpio_chip chip;
+	unsigned int regbase;
+	struct aaeonec_gpio_data *data;
+};
+
+struct aaeonec_gpio_data {
+	struct aaeonec_sio *sio;
+	int nr_bank;
+	struct aaeonec_gpio_bank *bank;
+};
+
+/*
+ * Super-I/O functions.
+ */
+
+static inline int superio_inb(int base, int reg)
+{
+	outb(reg, base);
+	return inb(base + 1);
+}
+
+static inline void superio_outb(int base, int reg, int val)
+{
+	outb(reg, base);
+	outb(val, base + 1);
+}
+
+static inline int superio_enter(int base)
+{
+	/* Don't step on other drivers' I/O space by accident. */
+	if (!request_muxed_region(base, 2, DRVNAME)) {
+		pr_err(DRVNAME "I/O address 0x%04x already in use\n", base);
+		return -EBUSY;
+	}
+
+	return 0;
+}
+
+static inline void superio_exit(int base)
+{
+	release_region(base, 2);
+}
+
+u8 ec_sio_read_byte(int base, u8 bLdn, u8 bReg)
+{
+	u8 bData = 0x00;
+
+	outb(EC_Device, base);
+	outb(bLdn, base + 1);
+
+	outb(bReg, base);
+	bData = inb(base + 1);
+
+	return bData;
+}
+
+void ec_sio_write_byte(int base, u8 bLdn, u8 bReg, u8 bData)
+{
+
+	outb(EC_Device, base);
+	outb(bLdn, base + 1);
+
+	outb(bReg, base);
+	outb(bData, base + 1);
+}
+
+u8 ec_read_byte(int base, u8 Device, u8 Type_Offset, u8 Data_offset)
+{
+	int i = 0;
+	int err = ETIMEDOUT;
+	u8 value = 0x00;
+
+
+	ec_sio_write_byte(base, Device, EC_TypeOffset, Type_Offset);
+	ec_sio_write_byte(base, Device, EC_CtlStatus, 0x10);
+
+	for (i = 0; i < 50; i++) {
+		msleep(1);
+		if ((ec_sio_read_byte(base,
+				      Device,
+				      EC_CtlStatus) & 0x02) == 0x02) {
+			err = EPERM;
+			break;
+		}
+		if ((ec_sio_read_byte(base,
+				      Device,
+				      EC_CtlStatus) & 0x01) == 0x01) {
+			err = 0;
+			break;
+		}
+	}
+
+	if (err == 0)
+		value = ec_sio_read_byte(base, Device, Data_offset);
+
+	return value;
+}
+
+void ec_write_byte(int base, u8 Device,
+		   u8 Type_Offset, u8 Data_offset, u8 Value)
+{
+	int i = 0;
+	int err = ETIMEDOUT;
+
+	ec_sio_write_byte(base, Device, EC_TypeOffset, Type_Offset);
+	ec_sio_write_byte(base, Device, EC_CtlStatus, 0x10);
+
+	for (i = 0; i < 50; i++) {
+		msleep(1);
+		if ((ec_sio_read_byte(base,
+				      Device,
+				      EC_CtlStatus) & 0x02) == 0x02) {
+			err = EPERM;
+			break;
+		}
+		if ((ec_sio_read_byte(base,
+				      Device,
+				      EC_CtlStatus) & 0x01) == 0x01) {
+			err = 0;
+			break;
+		}
+	}
+
+	if (err == 0) {
+		ec_sio_write_byte(base, Device, Data_offset, Value);
+		ec_sio_write_byte(base, Device, EC_CtlStatus, 0x30);
+
+		for (i = 0; i < 50; i++) {
+			msleep(1);
+			if ((ec_sio_read_byte(base,
+					      Device,
+					      EC_CtlStatus) & 0x02) == 0x02) {
+				err = EPERM;
+				break;
+			}
+			if ((ec_sio_read_byte(base,
+					      Device,
+					      EC_CtlStatus) & 0x01) == 0x01) {
+				err = 0;
+				break;
+			}
+		}
+	}
+}
+
+/*---------------------------------------------------------------*/
+/*
+ * GPIO chip.
+ */
+
+static int aaeonec_gpio_direction_in(struct gpio_chip *chip,
+				     unsigned int offset);
+static int aaeonec_gpio_get(struct gpio_chip *chip,
+			    unsigned int offset);
+static int aaeonec_gpio_direction_out(struct gpio_chip *chip,
+				      unsigned int offset, int value);
+static void aaeonec_gpio_set(struct gpio_chip *chip,
+			     unsigned int offset, int value);
+
+#define aaeonec_GPIO_BANK(_base, _ngpio, _regbase)			\
+	{								\
+		.chip = {						\
+			.label            = DRVNAME,			\
+			.owner            = THIS_MODULE,		\
+			.direction_input  = aaeonec_gpio_direction_in,	\
+			.get              = aaeonec_gpio_get,		\
+			.direction_output = aaeonec_gpio_direction_out,	\
+			.set              = aaeonec_gpio_set,		\
+			.base             = _base,			\
+			.ngpio            = _ngpio,			\
+			.can_sleep        = true,			\
+		},							\
+		.regbase = _regbase,					\
+	}
+
+#define gpio_dir(base) (base + 0)
+
+static struct aaeonec_gpio_bank ec_bank[] = {
+	aaeonec_GPIO_BANK(0, 8, 0x14),
+	aaeonec_GPIO_BANK(10, 8, 0x15),
+	aaeonec_GPIO_BANK(20, 8, 0x16),
+	aaeonec_GPIO_BANK(30, 8, 0x17),
+	aaeonec_GPIO_BANK(40, 8, 0x18),
+	aaeonec_GPIO_BANK(50, 8, 0x19),
+	aaeonec_GPIO_BANK(60, 8, 0x1A),
+	aaeonec_GPIO_BANK(70, 8, 0x1B),
+};
+
+static int aaeonec_gpio_direction_in(struct gpio_chip *chip,
+				     unsigned int offset)
+{
+	int err;
+	struct aaeonec_gpio_bank *bank =
+		container_of(chip, struct aaeonec_gpio_bank, chip);
+	struct aaeonec_sio *sio = bank->data->sio;
+	u8 dir;
+
+	err = superio_enter(sio->addr);
+	if (err)
+		return err;
+
+	dir = ec_read_byte(sio->addr, DIO_Func, DIO_Direction, bank->regbase);
+	dir |= (1 << offset);
+	ec_write_byte(sio->addr, DIO_Func, DIO_Direction, bank->regbase, dir);
+
+	superio_exit(sio->addr);
+
+	return 0;
+}
+
+static int aaeonec_gpio_get(struct gpio_chip *chip, unsigned int offset)
+{
+
+	int err;
+	int val = 0;
+	struct aaeonec_gpio_bank *bank =
+		container_of(chip, struct aaeonec_gpio_bank, chip);
+	struct aaeonec_sio *sio = bank->data->sio;
+	u8 data;
+
+	err = superio_enter(sio->addr);
+	if (err)
+		return err;
+
+	data = ec_read_byte(sio->addr, DIO_Func, DIO_Data, bank->regbase);
+
+	data &= (1 << offset);
+
+	if (data != 0x00)
+		val = 1;
+
+	superio_exit(sio->addr);
+
+	return val;
+}
+
+static int aaeonec_gpio_direction_out(struct gpio_chip *chip,
+				     unsigned int offset, int value)
+{
+	int err;
+	struct aaeonec_gpio_bank *bank =
+		container_of(chip, struct aaeonec_gpio_bank, chip);
+	struct aaeonec_sio *sio = bank->data->sio;
+	u8 dir;
+
+	err = superio_enter(sio->addr);
+	dir = ec_read_byte(sio->addr, DIO_Func, DIO_Direction, bank->regbase);
+	dir &= ~(1 << offset);
+	ec_write_byte(sio->addr, DIO_Func, DIO_Direction, bank->regbase, dir);
+
+
+	superio_exit(sio->addr);
+
+	return 0;
+
+}
+
+/* FIXME: double check the return value of this function */
+static void aaeonec_gpio_set(struct gpio_chip *chip,
+			     unsigned int offset, int value)
+{
+
+	int err;
+	struct aaeonec_gpio_bank *bank =
+		container_of(chip, struct aaeonec_gpio_bank, chip);
+	struct aaeonec_sio *sio = bank->data->sio;
+	u8 data_out;
+
+	err = superio_enter(sio->addr);
+	if (err)
+		return;
+	data_out = ec_read_byte(sio->addr, DIO_Func, DIO_Data, bank->regbase);
+	if (value)
+		data_out |= (1 << offset);
+	else
+		data_out &= ~(1 << offset);
+	ec_write_byte(sio->addr, DIO_Func, DIO_Data, bank->regbase, data_out);
+
+
+	superio_exit(sio->addr);
+
+	// return;
+}
+
+/*
+ * Platform device and driver.
+ */
+
+static int aaeonec_gpio_probe(struct platform_device *pdev)
+{
+	int err;
+	int i;
+	struct aaeonec_sio *sio = pdev->dev.platform_data;
+	struct aaeonec_gpio_data *data;
+
+	data = devm_kzalloc(&pdev->dev, sizeof(*data), GFP_KERNEL);
+	if (!data)
+		return -ENOMEM;
+
+	switch (sio->type) {
+	case aaeonec:
+		data->nr_bank = ARRAY_SIZE(ec_bank);
+		data->bank = ec_bank;
+		break;
+	default:
+		return -ENODEV;
+	}
+	data->sio = sio;
+
+	platform_set_drvdata(pdev, data);
+
+	/* For each GPIO bank, register a GPIO chip. */
+	for (i = 0; i < data->nr_bank; i++) {
+		struct aaeonec_gpio_bank *bank = &data->bank[i];
+
+		bank->chip.parent = &pdev->dev;
+
+		bank->data = data;
+
+		err = gpiochip_add(&bank->chip);
+		if (err) {
+			dev_err(&pdev->dev,
+				"Failed to register gpiochip %d: %d\n",
+				i, err);
+			goto err_gpiochip;
+		}
+	}
+
+	return 0;
+
+err_gpiochip:
+	for (i = i - 1; i >= 0; i--) {
+		struct aaeonec_gpio_bank *bank = &data->bank[i];
+
+		gpiochip_remove(&bank->chip);
+	}
+
+	return err;
+}
+
+static int aaeonec_gpio_remove(struct platform_device *pdev)
+{
+	int i;
+	struct aaeonec_gpio_data *data = platform_get_drvdata(pdev);
+
+	for (i = 0; i < data->nr_bank; i++) {
+		struct aaeonec_gpio_bank *bank = &data->bank[i];
+
+		gpiochip_remove(&bank->chip);
+	}
+
+	return 0;
+}
+
+static int __init aaeonec_find(int addr, struct aaeonec_sio *sio)
+{
+	int err;
+	u8 devid;
+
+	err = superio_enter(addr);
+	if (err)
+		return err;
+
+	err = -ENODEV;
+
+	devid = superio_inb(addr, SIO_DEVID);
+
+	switch (devid) {
+	case SIO_EC:
+		sio->type = aaeonec;
+		break;
+	default:
+		pr_info(DRVNAME ": Unsupported Fintek device 0x%04x\n", devid);
+		goto err;
+	}
+	sio->addr = SIO_ADDR;
+	err = 0;
+
+	pr_info(DRVNAME ": Found %s at %#x, revision %d\n",
+		aaeonec_names[sio->type],
+		(unsigned int) addr,
+		(int) superio_inb(addr, SIO_DEVREV));
+
+err:
+	superio_exit(addr);
+	return err;
+}
+
+static struct platform_device *aaeonec_gpio_pdev;
+
+static int __init
+aaeonec_gpio_device_add(const struct aaeonec_sio *sio)
+{
+	int err;
+
+	aaeonec_gpio_pdev = platform_device_alloc(DRVNAME, -1);
+	if (!aaeonec_gpio_pdev)
+		return -ENOMEM;
+
+	err = platform_device_add_data(aaeonec_gpio_pdev,
+				       sio, sizeof(*sio));
+	if (err) {
+		pr_err(DRVNAME "Platform data allocation failed\n");
+		goto err;
+	}
+
+	err = platform_device_add(aaeonec_gpio_pdev);
+	if (err) {
+		pr_err(DRVNAME "Device addition failed\n");
+		goto err;
+	}
+
+	return 0;
+
+err:
+	platform_device_put(aaeonec_gpio_pdev);
+
+	return err;
+}
+
+/*
+ * Try to match a supported Fintek device by reading the (hard-wired)
+ * configuration I/O ports. If available, then register both the platform
+ * device and driver to support the GPIOs.
+ */
+
+static struct platform_driver aaeonec_gpio_driver = {
+	.driver = {
+		.name	= DRVNAME,
+	},
+	.probe		= aaeonec_gpio_probe,
+	.remove		= aaeonec_gpio_remove,
+};
+
+static int __init aaeonec_gpio_init(void)
+{
+	int err;
+	struct aaeonec_sio sio;
+
+	if (aaeonec_find(0x6e, &sio) &&
+	    aaeonec_find(0x7e, &sio))
+		return -ENODEV;
+
+	err = platform_driver_register(&aaeonec_gpio_driver);
+	if (!err) {
+		err = aaeonec_gpio_device_add(&sio);
+		if (err)
+			platform_driver_unregister(&aaeonec_gpio_driver);
+	}
+
+	return err;
+}
+subsys_initcall(aaeonec_gpio_init);
+
+static void __exit aaeonec_gpio_exit(void)
+{
+	platform_device_unregister(aaeonec_gpio_pdev);
+	platform_driver_unregister(&aaeonec_gpio_driver);
+}
+module_exit(aaeonec_gpio_exit);
+
+MODULE_AUTHOR("Albert Wu <albertwu@aaeon.com.tw>");
+MODULE_DESCRIPTION("GPIO driver for Super-I/O chips EC");
+MODULE_LICENSE("GPL");
-- 
2.15.1

