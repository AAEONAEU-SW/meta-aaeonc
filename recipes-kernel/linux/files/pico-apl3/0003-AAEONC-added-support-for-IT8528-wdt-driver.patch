From b0a61920883c09f59b139d3a2708209e7c49903c Mon Sep 17 00:00:00 2001
From: Nicola Lunghi <nicola.lunghi@emutex.com>
Date: Mon, 18 Dec 2017 16:37:58 +0000
Subject: [PATCH 3/4] AAEONC: added support for IT8528 wdt driver

AAEONEC: watchdog: removed check for kernel version
AAEONEC: checkpatch cleanup of drivers/watchdog/ec_wdt.c

Signed-off-by: Nicola Lunghi <nicola.lunghi@emutex.com>
---
 drivers/watchdog/Kconfig  |   9 +
 drivers/watchdog/Makefile |   1 +
 drivers/watchdog/ec_wdt.c | 652 ++++++++++++++++++++++++++++++++++++++++++++++
 3 files changed, 662 insertions(+)
 create mode 100644 drivers/watchdog/ec_wdt.c

diff --git a/drivers/watchdog/Kconfig b/drivers/watchdog/Kconfig
index acb00b53a520..e59549f30186 100644
--- a/drivers/watchdog/Kconfig
+++ b/drivers/watchdog/Kconfig
@@ -789,6 +789,15 @@ config ALIM7101_WDT
 
 	  Most people will say N.
 
+config EC_WDT
+	tristate "Watchdog Timer found on IT8528 super i/o"
+	depends on X86
+	select WATCHDOG_CORE
+	help
+	  Enables watchdog timer support for the watchdog timer on the
+	  IT8528 super i/o. The timeout may be configured via
+	  the timeout module parameter.
+
 config EBC_C384_WDT
 	tristate "WinSystems EBC-C384 Watchdog Timer"
 	depends on X86 && ISA_BUS_API
diff --git a/drivers/watchdog/Makefile b/drivers/watchdog/Makefile
index 0c3d35e3c334..6033837dade4 100644
--- a/drivers/watchdog/Makefile
+++ b/drivers/watchdog/Makefile
@@ -98,6 +98,7 @@ obj-$(CONFIG_ACQUIRE_WDT) += acquirewdt.o
 obj-$(CONFIG_ADVANTECH_WDT) += advantechwdt.o
 obj-$(CONFIG_ALIM1535_WDT) += alim1535_wdt.o
 obj-$(CONFIG_ALIM7101_WDT) += alim7101_wdt.o
+obj-$(CONFIG_EC_WDT) += ec_wdt.o
 obj-$(CONFIG_EBC_C384_WDT) += ebc-c384_wdt.o
 obj-$(CONFIG_F71808E_WDT) += f71808e_wdt.o
 obj-$(CONFIG_SP5100_TCO) += sp5100_tco.o
diff --git a/drivers/watchdog/ec_wdt.c b/drivers/watchdog/ec_wdt.c
new file mode 100644
index 000000000000..278a24eafdff
--- /dev/null
+++ b/drivers/watchdog/ec_wdt.c
@@ -0,0 +1,652 @@
+/****************************************************************************
+ * Watchdog driver for Aaeon Super-I/O EC                                   *
+ *                                                                          *
+ * Copyright (C) 2017 Nick Chen <nick1chen@aaeon.com.tw>                    *
+ *                                                                          *
+ *    Based on ec_wdt.c by Jason Wang <jason2wang@aaeon.com.tw>             *
+ *                                                                          *
+ * This program is free software; you can redistribute it and/or modify     *
+ * it under the terms of the GNU General Public License as published by     *
+ * the Free Software Foundation; either version 2 of the License, or        *
+ * (at your option) any later version.                                      *
+ *                                                                          *
+ * This program is distributed in the hope that it will be useful,          *
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of           *
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the             *
+ * GNU General Public License for more details.                             *
+ *                                                                          *
+ * You should have received a copy of the GNU General Public License        *
+ * along with this program; if not, write to the                            *
+ * Free Software Foundation, Inc.,                                          *
+ * 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.                 *
+ ***************************************************************************/
+
+/*
+ * [x86] Add support for AAEON_EC hardware watchdogs
+ *   - resource: Add shared I/O region support
+ *   - watchdog: Add AAEON_EC driver
+ *
+ *  http://lxr.free-electrons.com/source/drivers/watchdog/f71808e_wdt.c?v=3.3
+ *  https://github.com/spotify/linux/blob/master/drivers/watchdog/f71808e_wdt.c
+ */
+
+#include <linux/err.h>
+#include <linux/fs.h>
+#include <linux/init.h>
+#include <linux/io.h>
+#include <linux/ioport.h>
+#include <linux/miscdevice.h>
+#include <linux/module.h>
+#include <linux/mutex.h>
+#include <linux/notifier.h>
+#include <linux/reboot.h>
+#include <linux/uaccess.h>
+#include <linux/watchdog.h>
+#include <linux/ioport.h>
+
+#define DRVNAME                 "aaeonec"
+
+/* Global Control Registers */
+#define SIO_ADDR                0x284
+#define SIO_EC_LD_REG		0x10
+#define SIO_EC_LF_REG		0x11
+#define SIO_EC_CTL_REG		0x12
+#define SIO_EC_LD_WDT           0xA8
+#define SIO_EC_FD_WDT           0x00
+#define SIO_EC_REG_WRITE	0x30
+#define SIO_EC_REG_READ		0x10
+#define SIO_REG_DEVID		0x20	/* Device ID (1 bytes) */
+#define SIO_REG_DEVREV		0x22	/* Device revision */
+#define SIO_REG_MANID		0x85	/* high byte of CHIP ID (1 bytes) */
+
+
+/* WDT Device Configuration Registers (LDN CR07) */
+#define EC_REG_WDT_CONF     0x14    /* WDT Control Register */
+#define EC_REG_WD_TIME      0x13    /* WDT Time Register */
+
+/* Watchdog Timer Function and WDT Control Register Flags */
+#define EC_FLAG_WD_UNIT       0       /* WD time unit */
+
+/* Default values */
+#define WATCHDOG_TIMEOUT        60      /* 1 minute default timeout */
+#define WATCHDOG_MAX_TIMEOUT    (60 * 255) /* WD_TIME is a byte long */
+
+/*  Module parameters */
+static unsigned short force_id;
+module_param(force_id, ushort, 0000);
+MODULE_PARM_DESC(force_id, " Override the detected device ID");
+
+static const int max_timeout = WATCHDOG_MAX_TIMEOUT;
+static int timeout = 60;                /* default timeout in seconds */
+module_param(timeout, int, 0000);
+MODULE_PARM_DESC(timeout,
+		" Watchdog timeout in seconds. 1<= timeout <="
+		__MODULE_STRING(WATCHDOG_MAX_TIMEOUT) " (default="
+		__MODULE_STRING(WATCHDOG_TIMEOUT) ")");
+
+static bool nowayout = WATCHDOG_NOWAYOUT;
+
+module_param(nowayout, bool, 0444);
+MODULE_PARM_DESC(nowayout, " Disable watchdog shutdown on close");
+
+static unsigned int start_withtimeout;
+module_param(start_withtimeout, uint, 0000);
+MODULE_PARM_DESC(start_withtimeout,
+	" Start watchdog timer on module load with given initial timeout. Zero (default) disables this feature.");
+
+/* Chips variants */
+enum chips { aaeonec };
+
+/* Chips Names */
+static const char * const chip_names[] = { "aaeonec" };
+
+/* Super-I/O Function prototypes */
+static inline int superio_enter(int base);
+static inline void superio_exit(int base);
+static inline void superio_select(int base, int ldn);
+static inline int superio_inb(int base, int reg);
+//static inline int superio_inw(int base, int reg);
+static inline void superio_outb(int base, int reg, u8 val);
+static inline void superio_set_bit(int base, int reg, int bit);
+static inline void superio_clear_bit(int base, int reg, int bit);
+
+/* Wdog internal data information */
+struct watchdog_data {
+	unsigned short	sioaddr;	/* default index port */
+	enum chips	type;		/* chip type */
+	unsigned long	opened;		/* driver open state */
+	struct mutex	lock;		/* concurrency control */
+	char		expect_close;	/* controlled close */
+	struct watchdog_info ident;	/* wdog information*/
+
+	unsigned short	timeout;	/* current wdog timeout */
+	u8 timer_val;			/* content for the WD_TIME register */
+	u8 timer_unit;			/* current timer unit, */
+					/*0 as second, 1 as minute */
+	u8 pulse_val;			/* pulse width flag */
+	char pulse_mode;		/* enable pulse output mode? */
+};
+
+static struct watchdog_data watchdog = {
+	.lock = __MUTEX_INITIALIZER(watchdog.lock),
+};
+
+/* Super I/O functions */
+static inline int superio_enter(int base)
+{
+	/* don't step on other drivers' I/O space by accident */
+	if (!request_muxed_region(base, 2, DRVNAME)) {
+		pr_err(": I/O address 0x%04x already in use\n", (int) base);
+		return -EBUSY;
+	}
+
+	return 0;
+}
+
+static inline void superio_exit(int base)
+{
+	release_region(base, 2);
+}
+
+static inline void superio_select(int base, int ldn)
+{
+	outb(SIO_EC_LD_REG, base);
+	outb(ldn, base + 1);
+}
+
+static inline int superio_inb(int base, int reg)
+{
+	outb(reg, base);
+	return inb(base + 1);
+}
+
+static inline void superio_outb(int base, int reg, u8 val)
+{
+	outb(reg, base);
+	outb(val, base + 1);
+}
+
+static inline void superio_set_bit(int base, int reg, int bit)
+{
+	unsigned long val = superio_inb(base, reg);
+
+	__set_bit(bit, &val);
+	superio_outb(base, reg, val);
+}
+
+static inline void superio_clear_bit(int base, int reg, int bit)
+{
+	unsigned long val = superio_inb(base, reg);
+
+	__clear_bit(bit, &val);
+	superio_outb(base, reg, val);
+}
+
+/* Internal Configuration functions */
+static int watchdog_set_timeout(int timeout)
+{
+	if (timeout <= 0 || timeout >  max_timeout) {
+		pr_err(DRVNAME ": watchdog timeout out of range\n");
+		return -EINVAL;
+	}
+
+	mutex_lock(&watchdog.lock);
+
+	watchdog.timeout = timeout;
+	if (timeout > 0xff) {
+		pr_info("current timer for minute is: %d\n",
+			DIV_ROUND_UP(timeout, 60));
+		watchdog.timer_val = DIV_ROUND_UP(timeout, 60);
+		watchdog.timer_unit = 1;
+	} else {
+		watchdog.timer_val = timeout;
+		watchdog.timer_unit = 0;
+	}
+
+	mutex_unlock(&watchdog.lock);
+	pr_info(DRVNAME ": watchdog_set_timeout(%d)...\n", timeout);
+	return 0;
+}
+
+/* Driver useful functions */
+static int watchdog_keepalive(void)
+{
+	int err = 0;
+
+	mutex_lock(&watchdog.lock);
+
+	err = superio_enter(watchdog.sioaddr);
+	if (err)
+		goto exit_unlock;
+
+	superio_select(watchdog.sioaddr, SIO_EC_LD_WDT);
+
+	/* Set Function Register to 00 */
+	superio_outb(watchdog.sioaddr, SIO_EC_LF_REG, SIO_EC_FD_WDT);
+
+	if (watchdog.timer_unit == 1)
+		superio_set_bit(watchdog.sioaddr,
+			EC_REG_WDT_CONF, EC_FLAG_WD_UNIT);
+	else
+		superio_clear_bit(watchdog.sioaddr,
+			EC_REG_WDT_CONF, EC_FLAG_WD_UNIT);
+
+	/* Set timer value */
+	superio_outb(watchdog.sioaddr, EC_REG_WD_TIME, watchdog.timer_val);
+
+	/* Reset Timer */
+	superio_outb(watchdog.sioaddr, SIO_EC_CTL_REG, SIO_EC_REG_WRITE);
+
+	superio_exit(watchdog.sioaddr);
+
+exit_unlock:
+	mutex_unlock(&watchdog.lock);
+
+	return err;
+}
+
+static int watchdog_start(void)
+{
+	int err = 0;
+
+	mutex_lock(&watchdog.lock);
+	err = superio_enter(watchdog.sioaddr);
+	if (err)
+		goto exit_unlock;
+
+	/* Watchdog output pin configuration */
+	switch (watchdog.type) {
+	case aaeonec:
+		/* Set pin 70 the function of WDTRST#/GPIO15 is WDTRST# */
+		pr_err(DRVNAME ": Set pin 70 the function of WDTRST#/GPIO15 is WDTRST#\n");
+		break;
+	default:
+		pr_err(DRVNAME ": Unable to configure WDTRST pin...\n");
+		err = -ENODEV;
+		goto exit_superio;
+	}
+
+	superio_select(watchdog.sioaddr, SIO_EC_LD_WDT);
+
+	superio_outb(watchdog.sioaddr, SIO_EC_LF_REG, SIO_EC_FD_WDT);
+
+	if (watchdog.timer_unit == 1)
+		superio_set_bit(watchdog.sioaddr,
+			EC_REG_WDT_CONF, EC_FLAG_WD_UNIT);
+	else
+		superio_clear_bit(watchdog.sioaddr,
+			EC_REG_WDT_CONF, EC_FLAG_WD_UNIT);
+
+	/* Set timer value */
+	superio_outb(watchdog.sioaddr, EC_REG_WD_TIME, watchdog.timer_val);
+
+	/* Enable WD */
+	superio_outb(watchdog.sioaddr, SIO_EC_CTL_REG, SIO_EC_REG_WRITE);
+
+exit_superio:
+	superio_exit(watchdog.sioaddr);
+exit_unlock:
+	mutex_unlock(&watchdog.lock);
+
+	pr_info(DRVNAME ": watchdog_start(%d)...\n", err);
+	return err;
+}
+
+static int watchdog_stop(void)
+{
+	int err = 0;
+
+	mutex_lock(&watchdog.lock);
+
+	err = superio_enter(watchdog.sioaddr);
+	if (err)
+		goto exit_unlock;
+
+	superio_select(watchdog.sioaddr, SIO_EC_LD_WDT);
+
+	superio_outb(watchdog.sioaddr, SIO_EC_LF_REG, SIO_EC_FD_WDT);
+
+	/* Set Timer to 0x00 to Stop counter */
+	superio_outb(watchdog.sioaddr, EC_REG_WD_TIME, 0x0);
+
+	/* Enable WD */
+	superio_outb(watchdog.sioaddr, SIO_EC_CTL_REG, SIO_EC_REG_WRITE);
+
+	superio_exit(watchdog.sioaddr);
+
+exit_unlock:
+	mutex_unlock(&watchdog.lock);
+
+	return err;
+}
+
+static bool watchdog_is_running(void)
+{
+	bool is_running = true;
+
+	mutex_lock(&watchdog.lock);
+
+	if (superio_enter(watchdog.sioaddr))
+		goto exit_unlock;
+
+	superio_select(watchdog.sioaddr, SIO_EC_LD_WDT);
+
+	superio_exit(watchdog.sioaddr);
+
+exit_unlock:
+	mutex_unlock(&watchdog.lock);
+
+	pr_info(DRVNAME ": watchdog_is_running(%s)...\n",
+		(is_running ? "Yes" : "No"));
+	return is_running;
+}
+
+/* /dev/watchdog api */
+static int watchdog_open(struct inode *inode, struct file *file)
+{
+	int err;
+
+	/* If the watchdog is alive we don't need to start it again */
+	if (test_and_set_bit(0, &watchdog.opened))
+		return -EBUSY;
+
+	err = watchdog_start();
+	if (err) {
+		clear_bit(0, &watchdog.opened);
+		pri_err(DRVNAME ": fail to open watchdog...\n");
+		return err;
+	}
+
+	if (nowayout)
+		__module_get(THIS_MODULE);
+
+	watchdog.expect_close = 0;
+
+	pr_info(DRVNAME ": watchdog open...\n");
+
+	return nonseekable_open(inode, file);
+}
+
+static int watchdog_release(struct inode *inode, struct file *file)
+{
+	clear_bit(0, &watchdog.opened);
+
+	if (!watchdog.expect_close) {
+		watchdog_keepalive();
+		pr_crit(DRVNAME ": Unexpected close, not stopping watchdog!\n");
+	} else if (!nowayout)
+		watchdog_stop();
+
+	pr_info(DRVNAME ": watchdog release...\n");
+	return 0;
+}
+
+static ssize_t watchdog_write(struct file *file, const char __user *buf,
+				size_t count, loff_t *ppos)
+{
+	if (count) {
+		if (!nowayout) {
+			size_t i;
+			/* In case it was set long ago */
+			bool expect_close = false;
+
+			for (i = 0; i != count; i++) {
+				char c;
+
+				if (get_user(c, buf + i))
+					return -EFAULT;
+
+				expect_close = (c == 'V');
+			}
+
+			/* Properly order writes across fork()ed processes */
+			mutex_lock(&watchdog.lock);
+			watchdog.expect_close = expect_close;
+			mutex_unlock(&watchdog.lock);
+		}
+
+		/* someone wrote to us, we should restart timer */
+		watchdog_keepalive();
+	}
+
+	return count;
+}
+
+static long watchdog_ioctl(struct file *file, unsigned int cmd,
+				unsigned long arg)
+{
+	int new_options;
+	int new_timeout;
+
+	union {
+		struct watchdog_info __user *ident;
+		int __user *i;
+	} uarg;
+
+	uarg.i = (int __user *) arg;
+
+	switch (cmd) {
+	case WDIOC_GETSUPPORT:
+		return copy_to_user(uarg.ident, &watchdog.ident,
+				sizeof(watchdog.ident)) ? -EFAULT : 0;
+
+	case WDIOC_GETBOOTSTATUS:
+		return put_user(0, uarg.i);
+
+	case WDIOC_SETOPTIONS:
+		if (get_user(new_options, uarg.i))
+			return -EFAULT;
+		if (new_options & WDIOS_DISABLECARD)
+			watchdog_stop();
+		if (new_options & WDIOS_ENABLECARD)
+			return watchdog_start();
+
+	case WDIOC_KEEPALIVE:
+		watchdog_is_running();
+		watchdog_keepalive();
+		return 0;
+
+	case WDIOC_SETTIMEOUT:
+		if (get_user(new_timeout, uarg.i))
+			return -EFAULT;
+		if (watchdog_set_timeout(new_timeout))
+			return -EINVAL;
+		watchdog_keepalive();
+
+	case WDIOC_GETTIMEOUT:
+		return put_user(watchdog.timeout, uarg.i);
+
+	default:
+		return -ENOTTY;
+	}
+}
+
+static int watchdog_notify_sys(struct notifier_block *this, unsigned long code,
+				void *unused)
+{
+	if (code == SYS_DOWN || code == SYS_HALT)
+		watchdog_stop();
+
+	return NOTIFY_DONE;
+}
+
+/* /dev/watchdog api available options */
+static const struct file_operations watchdog_fops = {
+	.owner              = THIS_MODULE,
+	.llseek             = no_llseek,
+	.open               = watchdog_open,
+	.release            = watchdog_release,
+	.write              = watchdog_write,
+	.unlocked_ioctl     = watchdog_ioctl,
+};
+
+static struct miscdevice watchdog_miscdev = {
+	.minor	= WATCHDOG_MINOR,
+	.name	= "watchdog",
+	.fops	= &watchdog_fops,
+};
+
+static struct notifier_block watchdog_notifier = {
+	.notifier_call = watchdog_notify_sys,
+};
+
+/* /dev/watchdog Main functions */
+static int __init watchdog_init(int sio_addr)
+{
+	int err = 0; //wdt_conf is in original code
+
+	watchdog.sioaddr = sio_addr;
+	watchdog.ident.options = WDIOC_SETTIMEOUT | WDIOF_MAGICCLOSE |
+		     WDIOF_KEEPALIVEPING;
+
+	snprintf(watchdog.ident.identity, sizeof(watchdog.ident.identity),
+		"%s watchdog", chip_names[watchdog.type]);
+
+	/* start wdog configuration */
+	err = superio_enter(watchdog.sioaddr);
+	if (err)
+		return err;
+
+	superio_select(watchdog.sioaddr, SIO_EC_LD_WDT);
+	superio_exit(watchdog.sioaddr);
+
+	err = watchdog_set_timeout(timeout);
+	if (err)
+		return err;
+
+	err = register_reboot_notifier(&watchdog_notifier);
+	if (err)
+		return err;
+
+	err = misc_register(&watchdog_miscdev);
+	if (err) {
+		pr_err(DRVNAME ": cannot register miscdev on minor=%d\n",
+			watchdog_miscdev.minor);
+		goto exit_reboot;
+	}
+
+	if (start_withtimeout) {
+		if (start_withtimeout <= 0 || start_withtimeout > max_timeout) {
+			pr_err(DRVNAME ": starting timeout out of range\n");
+			err = -EINVAL;
+			goto exit_miscdev;
+		}
+
+		err = watchdog_start();
+		if (err) {
+			pr_err(DRVNAME ": cannot start watchdog timer\n");
+			goto exit_miscdev;
+		}
+
+		mutex_lock(&watchdog.lock);
+		err = superio_enter(watchdog.sioaddr);
+		if (err)
+			goto exit_unlock;
+
+		superio_select(watchdog.sioaddr, SIO_EC_LD_WDT);
+
+		if (start_withtimeout > 0xff) {
+			/* select minutes for timer units */
+			superio_set_bit(watchdog.sioaddr, EC_REG_WDT_CONF,
+					EC_FLAG_WD_UNIT);
+			superio_outb(watchdog.sioaddr, EC_REG_WD_TIME,
+					DIV_ROUND_UP(start_withtimeout, 60));
+		} else {
+			/* select seconds for timer units */
+			superio_clear_bit(watchdog.sioaddr, EC_REG_WDT_CONF,
+					EC_FLAG_WD_UNIT);
+			superio_outb(watchdog.sioaddr, EC_REG_WD_TIME,
+					start_withtimeout);
+		}
+
+		superio_exit(watchdog.sioaddr);
+		mutex_unlock(&watchdog.lock);
+
+		if (nowayout)
+			__module_get(THIS_MODULE);
+
+		pr_info(DRVNAME
+			": watchdog started with initial timeout of %u sec\n",
+			start_withtimeout);
+	}
+
+	pr_info(DRVNAME
+		": watchdog started with  timeout of %u sec\n",
+		watchdog.timeout);
+	return 0;
+
+exit_unlock:
+	mutex_unlock(&watchdog.lock);
+exit_miscdev:
+	misc_deregister(&watchdog_miscdev);
+exit_reboot:
+	unregister_reboot_notifier(&watchdog_notifier);
+
+	return err;
+}
+
+static int __init aaeonec_find(int sio_addr)
+{
+	u16 devid;
+	int err = superio_enter(sio_addr);
+
+	if (err)
+		return err;
+
+	devid = superio_inb(sio_addr, SIO_REG_DEVID);
+
+	switch (devid) {
+	case SIO_REG_MANID:
+		watchdog.type = aaeonec;
+		break;
+	default:
+		pr_info(DRVNAME ": Unrecognized device: %04x\n",
+			(unsigned int) devid);
+		err = -ENODEV;
+		goto exit;
+	}
+
+	pr_info(DRVNAME ": Found %s watchdog chip, revision %d\n",
+
+	chip_names[watchdog.type], (int) superio_inb(sio_addr, SIO_REG_DEVREV));
+
+exit:
+	superio_exit(sio_addr);
+	return err;
+}
+
+static int __init aaeonec_init(void)
+{
+	static const unsigned short addrs[] = { 0x6e, 0x7e };
+	int err = -ENODEV, i;
+
+	for (i = 0; i < ARRAY_SIZE(addrs); i++) {
+		err = aaeonec_find(addrs[i]);
+		if (err == 0)
+			break;
+	}
+
+	if (i == ARRAY_SIZE(addrs))
+		return err;
+
+	return watchdog_init(SIO_ADDR);
+}
+
+static void __exit aaeonec_exit(void)
+{
+	if (watchdog_is_running()) {
+		pr_warn(DRVNAME ": Watchdog timer still running, stopping it\n");
+
+	watchdog_stop();
+}
+
+misc_deregister(&watchdog_miscdev);
+unregister_reboot_notifier(&watchdog_notifier);
+}
+
+MODULE_AUTHOR("Nick Chen <nick1chen@aaeon.com.tw>");
+MODULE_DESCRIPTION("Hardware Watchdog Device Driver for AAEON_EC chip I/O");
+MODULE_LICENSE("GPL");
+
+module_init(aaeonec_init);
+module_exit(aaeonec_exit);
-- 
2.15.1

